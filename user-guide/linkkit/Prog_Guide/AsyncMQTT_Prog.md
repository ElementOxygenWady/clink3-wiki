# <a name="目录">目录</a>
+ [C-SDK对异步通知式底层通信模型的支持](#C-SDK对异步通知式底层通信模型的支持)
    * [使用C-SDK时的典型应用方式](#使用C-SDK时的典型应用方式)
    * [在异步通知式协议栈系统上的矛盾](#在异步通知式协议栈系统上的矛盾)
    * [为解决矛盾做出的改造](#为解决矛盾做出的改造)

# <a name="C-SDK对异步通知式底层通信模型的支持">C-SDK对异步通知式底层通信模型的支持</a>

> C-SDK被设计为可移植到多种目标嵌入式平台, 所以它是通过外界提供的 `HAL_TCP_Read()` 和 `HAL_TCP_Write()` 这类抽象的 "底层通信" 接口进行网络报文的收取和发送

## <a name="使用C-SDK时的典型应用方式">使用C-SDK时的典型应用方式</a>

C-SDK需要被移植到的大多数目标嵌入式平台都使用 **同步** 的底层通信模型, 能够支持C-SDK用 **轮询** 的方式主动去网络上收取报文, 当然也可以主动的去发送报文

+ 比如, 我们熟悉的嵌入式 `Linux` 系统, `Windows` 系统, 以及大部分配备lwip协议栈通信的RTOS比如 `FreeRTOS` 系统等, 它们都支持上层应用随时去 **主动** 收取网络报文
+ 在这样的系统上, C-SDK这样的网络应用软件, 可以 **随时的** 和 **主动的** 调用类似 `read()` 这样的函数接口从已开启的socket接口收取报文

---
因此, C-SDK最初被编写为以 **轮询方式** 去和底层通信软件模块交互: 当它的 `IOT_MQTT_Yield()` 接口被调用时, 去做从网络上收取云端下发报文的动作

<br>
<img src="https://code.aliyun.com/edward.yangx/public-docs/raw/master/images/polling_mqtt_flow.png" width="800" height="600" />

---
如上图所示, 则是使用C-SDK的一个典型应用程序结构

+ 首先应用通过 `IOT_MQTT_Construct()` 建立IoT设备与云端之间的长连接通道
+ 然后在这个长连接上用 `IOT_MQTT_Subscribe()` 订阅一些Topic, 表达自己将可接受哪些消息报文的下发, 并设置这些消息到达后处理它们的回调函数
+ 达到初始化就绪状态, 进入主要的业务逻辑循环

    + 应用程序想要发送数据时, 调用 `IOT_MQTT_Publish()`, 将消息报文向云端上报
    + 应用程序想要接收数据时, 调用 `IOT_MQTT_Yield()`, 不仅可以收取云端下发的报文, 也完成了必要的重发和心跳的维持

## <a name="在异步通知式协议栈系统上的矛盾">在异步通知式协议栈系统上的矛盾</a>

> 然而, 上面这样典型的程序结构在某些使用异步通知式TCP/IP协议栈的OS上, 比如 `MTK2503/MTK6261` 芯片自带的 `Nucleus` 系统时, 并不适用

关键的冲突点是: 收包动作的主动方不再是应用程序, 而是协议栈等底层通信模块
---
+ 这类OS的协议栈并不支持上层应用 **随时的** 和 **主动的** 来底层通信模块收取网络报文

    + 比如 `MTK2503/MTK6261` 上的 `Nucleus`, 它支持的是应用向底层注册有网络消息到达时的回调函数
    + 然后如果有网络上的报文抵达, TCP/IP协议栈 **反过来** 调用之前被注册的回调函数来告诉上层应用, 当前有报文待处理
    + 如果并未收到底层的通知, 上层应用 **主动的** 去收报文是不行的

+ 这样一来, 应用程序就不再能像上图所示的那样自己控制接收消息的节奏, 会出现收的时候没有报文, 有报文的时候没去收的错误局面
+ **对这种类型的系统, 我们称它们为使用了 "异步" 的, "通知式" 的底层通信模块的系统, 因为应用接收网络消息的动作是被底层通知的, 而非应用主控**

<br>
*注: 也有人将这种方式称为 "事件驱动式" 的, 或者 "网络驱动式" 的编程模型*

<br>
在过去, 很多开发者碰到了将C-SDK向 `MTK2503/MTK6261` 这样的 `GPRS` 通信芯片移植上的困难, 而官方C-SDK并未为此提供好的开发基础

## <a name="为解决矛盾做出的改造">为解决矛盾做出的改造</a>
在V3.0.1以上版本, C-SDK将支持切换到异步编程模型, 通过 `Main Menu` -> `MQTT Configurations` -> `FEATURE_ASYNC_PROTOCOL_STACK` 开关打开即可完成切换

<br>
<img src="https://code.aliyun.com/edward.yangx/public-docs/raw/master/images/notify_mqtt_flow.png" width="800" height="700" />

---
如上图所示, 当 `FEATURE_ASYNC_PROTOCOL_STACK` 开关打开时, C-SDK配合的应用程序可以如下结构编写

+ 首先应用通过 `IOT_MQTT_Construct()` 建立IoT设备与云端之间的长连接通道
+ 然后编写和注册一个用户在此长连接上接收报文的回调函数, 它 **包含了** 接口 `IOT_MQTT_Nwk_Event_Handler()`
    + 底层模块收到报文之后, 将进入这个回调函数, 用户可以在这个回调函数中对报文做一些识别和初步处理
    + 下一步即可将报文通过 `IOT_MQTT_Nwk_Event_Handler()` 交给SDK, 比如, SDK会识别其中的Topic分发给 `IOT_MQTT_Subscribe()` 时设置的报文处理函数
+ 原来的 `IOT_MQTT_Publish()` 仍可同样使用, 因为虽然应用不再能 **主动收包**, 但 **主动发包** 还是可以的
+ 原来的 `IOT_MQTT_Yield()` 已经发生了变化, 简单的说, 就是 **只发不收**
    + 重传云端尚未应答的 QoS1 消息仍然进行
    + 若达到心跳间隔, 则发送心跳维持连接仍然进行
    + 但以前通过 `HAL_TCP_Read()` 等接口去网络收取报文并做分发处理的逻辑已全部关闭, 改到被底层通知时才会去做

---
以上就是C-SDK为支持异步协议栈做出的改造, 我们在 `MTK2503/MTK6261` 的 `Nucleus` 上完成了这种改造的开发和验证, 详见: [移植到联发科MTK2503/MTK6261](http://code.aliyun.com/edward.yangx/public-docs/wikis/user-guide/linkkit/Port_Guide/Build_MTK2503)
